plugins {
    id "com.jfrog.artifactory" version "3.0.1"
}
apply plugin: 'cpp'
apply plugin: 'java'
apply plugin: 'maven-publish'

archivesBaseName = 'jtnoodle'
version = '0.0.1-SNAPSHOT'
group = 'tk.tnoodle'

sourceCompatibility = 1.6

libraries {
    tnoodle {}
    tnoodlejni {}
}

executables {
    main {}
}

sources {
    main {
        cpp {
            lib libraries.tnoodle
        }
    }
    tnoodlejni {
        cpp {
            lib libraries.tnoodle.static
        }
    }
}
// Ignore .swp files everywhere
for(source in sources) {
    if(!source.hasProperty('cpp')) {
        continue
    }
    source.cpp.source.excludes += "**/*.swp"
}

sourceSets {
    jtnoodle
}

// TODO - there must be a better way to get the headers directory
// for jtnoodle. I couldn't find anything under
// sources.jtnoodle.cpp.exportedHeaders, though.
def nativeHeadersDir = file("$projectDir/src/tnoodlejni/headers")

task nativeHeaders() {
    def outputFile = file("$nativeHeadersDir/tnoodlejni.h")
    inputs.files sourceSets.jtnoodle.output
    outputs.file outputFile
    doLast {
        outputFile.parentFile.mkdirs()
        exec {
            executable org.gradle.internal.jvm.Jvm.current().getExecutable('javah')
            args '-o', outputFile
            args '-classpath', sourceSets.jtnoodle.output.classesDir
            args 'JTNoodle'
        }
    }
}

def exists(bin) {
    ByteArrayOutputStream stdOut = new ByteArrayOutputStream()
    def r = exec {
        commandLine = [
            "bash", "-c", "which ${bin} 2>&1"
        ]
        standardOutput = stdOut
        ignoreExitValue = true
    }
    if(r.exitValue == 0) {
        // which found the file
        return true
    } else if(r.exitValue == 1) {
        // which failed to find the file
        return false
    } else {
        // Some other error occurred while invoking bash
        throw new GradleScriptException(stdOut.toString(), null)
    }
}

model {
    platforms {
        // We're only targeting 64-bit binaries on OS X for now.
        linux_x86_64 {
            architecture "x86_64"
            operatingSystem "linux"
        }
        linux_x86 {
            architecture "x86"
            operatingSystem "linux"
        }
        windows_x86_64 {
            architecture "x86_64"
            operatingSystem "windows"
        }
        windows_x86 {
            architecture "x86"
            operatingSystem "windows"
        }
        osx_x86_64 {
            architecture "x86_64"
            operatingSystem "osx"
        }
    }
    toolChains {
        // We only support building with clang.
        //gcc(Gcc) 
        clang(Clang)

        if(exists("x86_64-w64-mingw32-g++")) {
            mingw(Gcc) {
                target "windows_x86_64"
                // Call to eachPlatform comes from
                // https://github.com/gradle/gradle/commit/f0040d4520a748744c7f7bccf111ba2e1422e34f
                eachPlatform {
                    cCompiler.executable = "x86_64-w64-mingw32-gcc"
                    cppCompiler.executable = "x86_64-w64-mingw32-g++"
                    // http://stackoverflow.com/a/4981870
                    linker.executable = "x86_64-w64-mingw32-g++"
                    assembler.executable = "x86_64-w64-mingw32-as"
                    staticLibArchiver.executable = "x86_64-w64-mingw32-ar"
                }
            }
        }
        if(exists("i686-w64-mingw32-g++")) {
            mingw(Gcc) {
                target "windows_x86"
                eachPlatform {
                    cCompiler.executable = "i686-w64-mingw32-gcc"
                    cppCompiler.executable = "i686-w64-mingw32-g++"
                    // http://stackoverflow.com/a/4981870
                    linker.executable = "i686-w64-mingw32-g++"
                    assembler.executable = "i686-w64-mingw32-as"
                    staticLibArchiver.executable = "i686-w64-mingw32-ar"
                }
            }
        }
        if(exists("x86_64-apple-darwin12-clang++")) {
            osxcross(Clang) {
                target "osx_x86_64"
                eachPlatform {
                    cCompiler.executable = "x86_64-apple-darwin12-clang"
                    cppCompiler.executable = "x86_64-apple-darwin12-clang++"
                    // http://stackoverflow.com/a/4981870
                    linker.executable = "x86_64-apple-darwin12-clang++"
                    assembler.executable = "x86_64-apple-darwin12-as"
                    staticLibArchiver.executable = "x86_64-apple-darwin12-ar"
                }
            }
        }
        all {
            eachPlatform {
                cppCompiler.withArguments { args ->
                    args << '-I' << "${org.gradle.internal.jvm.Jvm.current().javaHome}/include"
                    args << '-I' << "${org.gradle.internal.jvm.Jvm.current().javaHome}/include/linux"
                    // The following are not needed to compile on linux, but are useful for developing on OS X.
                    args << '-I' << "${org.gradle.internal.jvm.Jvm.current().javaHome}/include/darwin"
                    args << '-I' << "/System/Library/Frameworks/JavaVM.framework/Versions/A/Headers/"
                    if(!cppCompiler.executable.contains("mingw")) {
                        // Don't bother with fPIC for windows.
                        args << "-fPIC"
                        if(cppCompiler.executable.contains("darwin")) {
                            args << "-stdlib=libc++"
                        } else {
                            args << "-stdlib=libstdc++"
                        }
                    }
                    args << "-std=c++11"
                    args << "-D__STRICT_ANSI__" // http://llvm.org/bugs/show_bug.cgi?id=13530#c3
                }
            }
            tasks.withType(CppCompile) { task ->
                task.dependsOn nativeHeaders
            }
        }
    }
}

// Task to build all shared libraries that we are capable of building.
task buildSharedLibraries {
    dependsOn binaries.withType(SharedLibraryBinary).matching {
        it.buildable
    }
    dependsOn jtnoodleClasses
}

task copySharedLibrariesToJava(type: Copy, dependsOn: buildSharedLibraries) {
    from {
        libraries.tnoodlejni.binaries.withType(SharedLibraryBinary).collect {
            def containingFolder = it.sharedLibraryFile.getParentFile()
            fileTree(dir: containingFolder.getParentFile(),
                     include: containingFolder.getName() + "/**")
        }
    }
    into new File(sourceSets.jtnoodle.output.classesDir, "/native/")
}

task run(type: JavaExec, dependsOn: copySharedLibrariesToJava) {
    main = "Main"
    classpath = sourceSets.jtnoodle.runtimeClasspath
}

jar {
    from sourceSets.jtnoodle.output
    manifest {
        attributes 'Main-Class': 'Main'
    }
}
jar.dependsOn copySharedLibrariesToJava

task sourcesJar(type: Jar) {
    classifier = 'sources'
    from sourceSets.jtnoodle.java.srcDirs
}

publishing {
    publications {
        mavenJava(MavenPublication) {
            // Produce jtnoodle.jar instead of libtnoodle.jar
            artifactId "jtnoodle"
            from components.java
            artifact sourcesJar {
                classifier "sources"
            }
            pom.withXml {
                // Trick from
                // http://mike-neck.github.io/blog/2013/06/21/how-to-publish-artifacts-with-gradle-maven-publish-plugin-version-1-dot-6/
                asNode().children().last() + {
                    resolveStrategy = Closure.DELEGATE_FIRST
                    name 'jtnoodle'
                    description 'Scrambling software for WCA competitions'
                    url 'https://github.com/jfly/libtnoodle'
                    scm {
                        url 'https://github.com/jfly/libtnoodle'
                        connection 'https://github.com/jfly/libtnoodle.git'
                        developerConnection 'git@github.com:jfly/libtnoodle.git'
                    }
                    licenses {
                        license {
                            name 'GNU General Public License, Version 3'
                            url 'http://www.gnu.org/licenses/gpl-3.0-standalone.html'
                            distribution 'repo'
                        }
                    }
                    developers {
                        developer {
                            id 'jfly'
                            name 'Jeremy Fleischman'
                            email 'jeremyfleischman@gmail.com'
                        }
                    }
                }
            }
        }
    }
    repositories {
        maven {
            url "$buildDir/repo"
        }
    }
}

def ENV = System.getenv()
def artifactory_user = null
if(hasProperty('artifactory_user')) {
    artifactory_user = property('artifactory_user')
} else {
    artifactory_user = ENV['artifactory_user']
}
def artifactory_password = null
if(hasProperty('artifactory_password')) {
    artifactory_password = property('artifactory_password')
} else {
    artifactory_password = ENV['artifactory_password']
}

artifactory {
    contextUrl = "http://oss.jfrog.org/artifactory"
    publish {
        repository {
            repoKey = 'oss-snapshot-local'
            username = "${artifactory_user}"
            password = "${artifactory_password}"
            maven = true
        }
        defaults {
            //This closure defines defaults for all 'artifactoryPublish' tasks
            // of all projects the plugin is applied to
            publications ('mavenJava')
        }
    }
    resolve {
        repository {
            repoKey = 'libs-release'
            username = "${artifactory_user}"
            password = "${artifactory_password}"
            maven = true
        }
    }
}


task wrapper(type: Wrapper) {
    // We need a version of gradle with
    // https://github.com/gradle/gradle/commit/0cd1cff47d044f038db61287c4d9e0fd93691951
    gradleVersion = '2.2-20140911220012+0000'
}
