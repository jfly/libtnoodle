apply plugin: 'cpp'
apply plugin: 'java'

libraries {
    tnoodle {}
    tnoodlejni {}
}

executables {
    main {}
}

sources {
    main {
        cpp {
            lib libraries.tnoodle
        }
    }
    tnoodlejni {
        cpp {
            lib libraries.tnoodle.static
        }
    }
}
// Ignore .swp files everywhere
for(source in sources) {
    if(!source.hasProperty('cpp')) {
        continue
    }
    source.cpp.source.excludes += "**/*.swp"
}

sourceSets {
    jtnoodle
}

jar {
    from sourceSets.jtnoodle.output
}

// TODO - there must be a better way to get the headers directory
// for jtnoodle. I couldn't find anything under
// sources.jtnoodle.cpp.exportedHeaders, though.
def nativeHeadersDir = file("$projectDir/src/tnoodlejni/headers")

task nativeHeaders() {
    def outputFile = file("$nativeHeadersDir/tnoodlejni.h")
    inputs.files sourceSets.jtnoodle.output
    outputs.file outputFile
    doLast {
        outputFile.parentFile.mkdirs()
        exec {
            executable org.gradle.internal.jvm.Jvm.current().getExecutable('javah')
            args '-o', outputFile
            args '-classpath', sourceSets.jtnoodle.output.classesDir
            args 'JTNoodle'
        }
    }
}

model {
    platforms {
        // For ease of development, my is a nice default that
        // will figure out which architecture and
        // operatingSystem we're on.
        my {}
        linux_x86 {
            architecture "x86"
            operatingSystem "linux"
        }
        linux_x64 {
            architecture "x86_64"
            operatingSystem "linux"
        }
        windows_x86 {
            architecture "x86"
            operatingSystem "windows"
        }
        windows_x64 {
            architecture "x86_64"
            operatingSystem "windows"
        }
        osx_x86 {
            architecture "x86"
            operatingSystem "osx"
        }
        osx_x64 {
            architecture "x86_64"
            operatingSystem "osx"
        }
    }
    toolChains {
        gcc(Gcc)
        clang(Clang)
        mingw(Gcc) {
            target "windows_x64"
            cCompiler.executable = "x86_64-w64-mingw32-gcc"
            cppCompiler.executable = "x86_64-w64-mingw32-g++"
            // http://stackoverflow.com/a/4981870
            linker.executable = "x86_64-w64-mingw32-g++"
            assembler.executable = "x86_64-w64-mingw32-as"
        }
        mingw(Gcc) {
            target "windows_x86"
            cCompiler.executable = "i686-w64-mingw32-gcc"
            cppCompiler.executable = "i686-w64-mingw32-g++"
            // http://stackoverflow.com/a/4981870
            linker.executable = "i686-w64-mingw32-g++"
            assembler.executable = "i686-w64-mingw32-as"
        }
        all {
            cppCompiler.withArguments { args ->
                args << '-I' << "${org.gradle.internal.jvm.Jvm.current().javaHome}/include"
                args << '-I' << "${org.gradle.internal.jvm.Jvm.current().javaHome}/include/linux"
            }
            tasks.withType(CppCompile) { task ->
                task.dependsOn nativeHeaders
            }
        }
    }
}

// Task to build all executables that we are capable of building.
task buildAllExecutables {
    dependsOn binaries.withType(ExecutableBinary).matching {
        it.buildable
    }
}


task wrapper(type: Wrapper) {
    gradleVersion = '2.1'
}
